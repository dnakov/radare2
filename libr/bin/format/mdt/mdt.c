// SPDX-FileCopyrightText: 2025 Rot127 <unisono@quyllur.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"mdt.h\"\n#include \"../elf/elf.h\"\n#include <r_bin.h>\n#include <r_util.h>\n#include <r_io.h>\n\nstatic inline bool is_layout_bin(size_t p_flags) {\n\treturn (p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_LAYOUT;\n}\n\nstatic inline bool is_elf32(RBuffer *b) {\n\tut8 header[16];\n\tif (r_buf_read_at(b, 0, header, sizeof(header)) != sizeof(header)) {\n\t\treturn false;\n\t}\n\treturn memcmp(header, \"\\x7f\" \"ELF\", 4) == 0 && header[4] == 1;  // ELFCLASS32\n}\n\n// Virtual file helper functions\nRBinVirtualFile *r_bin_virtual_file_new(const char *name, RBuffer *buf, bool buf_owned) {\n\tRBinVirtualFile *vfile = R_NEW0(RBinVirtualFile);\n\tif (!vfile) {\n\t\treturn NULL;\n\t}\n\tvfile->name = name ? strdup(name) : NULL;\n\tvfile->buf = buf;\n\tvfile->buf_owned = buf_owned;\n\treturn vfile;\n}\n\nvoid r_bin_virtual_file_free(RBinVirtualFile *vfile) {\n\tif (!vfile) {\n\t\treturn;\n\t}\n\tif (vfile->buf_owned) {\n\t\tr_buf_free(vfile->buf);\n\t}\n\tfree(vfile->name);\n\tfree(vfile);\n}\n\nRBinVirtualFile *r_bin_virtual_file_clone(RBinVirtualFile *vfile) {\n\tif (!vfile) {\n\t\treturn NULL;\n\t}\n\tRBinVirtualFile *clone = R_NEW0(RBinVirtualFile);\n\tif (!clone) {\n\t\treturn NULL;\n\t}\n\tclone->name = vfile->name ? strdup(vfile->name) : NULL;\n\tclone->buf = vfile->buf;\n\tclone->buf_owned = false;  // Don't own the buffer in clones\n\treturn clone;\n}\n\nRBinMdtPart *r_bin_mdt_part_new(const char *name, size_t p_flags) {\n\tRBinMdtPart *part = R_NEW0(RBinMdtPart);\n\tif (!part) {\n\t\treturn NULL;\n\t}\n\tpart->name = name ? strdup(name) : NULL;\n\tpart->relocatable = p_flags & QCOM_MDT_RELOCATABLE;\n\tpart->is_layout = is_layout_bin(p_flags);\n\tpart->symbols = r_list_newf((RListFree)r_bin_symbol_free);\n\tpart->relocs = r_list_newf(free);\n\tpart->sections = r_list_newf((RListFree)r_bin_section_free);\n\tpart->sub_maps = r_list_newf(free);\n\treturn part;\n}\n\nvoid r_bin_mdt_part_free(RBinMdtPart *part) {\n\tif (!part) {\n\t\treturn;\n\t}\n\tr_bin_virtual_file_free(part->vfile);\n\tswitch (part->format) {\n\tdefault:\n\t\tbreak;\n\tcase R_BIN_MDT_PART_ELF:\n\t\tElf_(free)(part->obj.elf);\n\t\tbreak;\n\tcase R_BIN_MDT_PART_MBN:\n\t\tfree(part->obj.mbn);\n\t\tbreak;\n\t}\n\tfree(part->map);\n\tr_list_free(part->relocs);\n\tr_list_free(part->symbols);\n\tr_list_free(part->sections);\n\tr_list_free(part->sub_maps);\n\tfree(part->patches_vfile_name);\n\tfree(part->relocs_vfile_name);\n\tfree(part->name);\n\tfree(part);\n}\n\nRBinMdtObj *r_bin_mdt_obj_new() {\n\tRBinMdtObj *obj = R_NEW0(RBinMdtObj);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tobj->parts = r_list_newf((RListFree)r_bin_mdt_part_free);\n\treturn obj;\n}\n\nvoid r_bin_mdt_obj_free(RBinMdtObj *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\tElf_(free)(obj->header);\n\tr_list_free(obj->parts);\n\tfree(obj->name);\n\tfree(obj);\n}\n\nbool r_bin_mdt_check_buffer(RBuffer *b) {\n\tR_RETURN_VAL_IF_FAIL(b, false);\n\tif (!is_elf32(b) || r_buf_size(b) <= 52) { // Minimum ELF32 header size\n\t\treturn false;\n\t}\n\n\tvoid *elf = Elf_(new_buf)(b, 0, false);\n\tif (!elf) {\n\t\treturn false;\n\t}\n\t\n\t// Get first program header to check for MDT flags\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)elf;\n\tif (ehdr->e_phnum == 0) {\n\t\tElf_(free)(elf);\n\t\treturn false;\n\t}\n\t\n\t// Read first program header\n\tElf32_Phdr phdr;\n\tif (r_buf_read_at(b, ehdr->e_phoff, (ut8*)&phdr, sizeof(phdr)) != sizeof(phdr)) {\n\t\tElf_(free)(elf);\n\t\treturn false;\n\t}\n\t\n\tbool mdt_flags_set = is_layout_bin(phdr.p_flags);\n\tElf_(free)(elf);\n\treturn mdt_flags_set;\n}\n\nstatic bool load_unidentified_obj_data(RBinMdtPart *part, void *segment, RBinVirtualFile *vfile, RBinMap *map) {\n\tR_RETURN_VAL_IF_FAIL(part && segment && vfile && map, false);\n\treturn true;\n}\n\nstatic bool load_mbn_obj_data(RBinMdtPart *part, void *segment, RBinVirtualFile *vfile, RBinMap *map) {\n\tR_RETURN_VAL_IF_FAIL(part && segment && vfile && map, false);\n\n\tSblHeader *mbn = R_NEW0(SblHeader);\n\tut64 offset = 0;\n\tif (!mbn) {\n\t\treturn false;\n\t}\n\t\n\t// Read MBN header - structure from bin_mbn.c\n\tif (r_buf_read_at(vfile->buf, offset, (ut8*)mbn, sizeof(SblHeader)) != sizeof(SblHeader)) {\n\t\tfree(mbn);\n\t\treturn false;\n\t}\n\t\n\t// Basic validation\n\tif (mbn->version != 3) { // NAND\n\t\tfree(mbn);\n\t\treturn false;\n\t}\n\t\n\tpart->obj.mbn = mbn;\n\treturn true;\n}\n\nstatic void prefix_name(char **to_prefix, const char *prefix) {\n\tR_RETURN_IF_FAIL(to_prefix && prefix);\n\tconst char *separator = (*to_prefix)[0] == '.' ? \"\" : \".\";\n\tchar *prefixed_name = r_str_newf(\"%s%s%s\", prefix, separator, \n\t\t\t\t\t R_STR_ISEMPTY(*to_prefix) ? \"0x0\" : *to_prefix);\n\tfree(*to_prefix);\n\t*to_prefix = prefixed_name;\n}\n\nstatic bool load_elf_obj_data(RBinMdtPart *part, void *segment, RBinVirtualFile *vfile, RBinMap *map, bool big_endian) {\n\tR_RETURN_VAL_IF_FAIL(part && segment && vfile && map, false);\n\n\tvoid *elf = Elf_(new_buf)(vfile->buf, 0, false);\n\tif (!elf) {\n\t\tR_LOG_ERROR(\"Failed to load segment '%s' as ELF.\\n\", part->name);\n\t\treturn false;\n\t}\n\n\tpart->obj.elf = elf;\n\tpart->patches_vfile_name = r_str_newf(\"patches.%s\", part->name);\n\tpart->relocs_vfile_name = r_str_newf(\"relocs.%s\", part->name);\n\n\t// TODO: Add symbol/section/reloc extraction here\n\t// This requires more complex ELF parsing that would need significant\n\t// additional work to port from Rizin's advanced ELF handling\n\t\n\treturn true;\n}\n\nstatic RBinSection *elf_to_bin_segment(void *segment_ptr, const char *name) {\n\tRBinSection *bseg = R_NEW0(RBinSection);\n\tif (!bseg) {\n\t\treturn NULL;\n\t}\n\n\t// Cast to Elf32_Phdr\n\tElf32_Phdr *segment = (Elf32_Phdr *)segment_ptr;\n\t\n\tbseg->paddr = segment->p_paddr;\n\tbseg->size = segment->p_filesz;\n\tbseg->vsize = segment->p_memsz;\n\tbseg->vaddr = segment->p_vaddr;\n\tbseg->perm = segment->p_flags & (PF_X | PF_W | PF_R);\n\tbseg->is_segment = true;\n\tbseg->is_data = !(segment->p_flags & PF_X);\n\tbseg->flags = segment->p_flags;\n\tbseg->name = name ? strdup(name) : NULL;\n\treturn bseg;\n}\n\nstatic RBinMdtPart *segment_to_mdt_part(void *segment_ptr, size_t part_num, const char *suffix_less_path, bool big_endian) {\n\tElf32_Phdr *segment = (Elf32_Phdr *)segment_ptr;\n\tRBuffer *vfile_buffer = NULL;\n\tchar *segment_file_path = NULL;\n\tRBinMdtPart *part = NULL;\n\tRBinMap *map = NULL;\n\tRBinVirtualFile *vfile = NULL;\n\n\tsegment_file_path = r_str_newf(\"%s.b%02zu\", suffix_less_path, part_num);\n\tif (!segment_file_path) {\n\t\tgoto error;\n\t}\n\tconst char *segment_name = r_file_basename(segment_file_path);\n\tif (!segment_name) {\n\t\tsegment_name = segment_file_path;\n\t}\n\tpart = r_bin_mdt_part_new(segment_name, segment->p_flags);\n\tif (!part) {\n\t\tgoto error;\n\t}\n\n\tbool segment_file_exists = r_file_exists(segment_file_path);\n\tbool zero_segment = segment->p_filesz == 0;\n\tif (zero_segment && segment_file_exists) {\n\t\tR_LOG_WARN(\"The segment size for '%s' is 0. But the file exists. Skip loading.\\n\", segment_file_path);\n\t\tgoto error;\n\t} else if (!zero_segment && !segment_file_exists) {\n\t\tR_LOG_WARN(\"The segment size for '%s' is 0x%x. But the file doesn't exist. Skip loading.\\n\", \n\t\t\t   segment_file_path, segment->p_filesz);\n\t\tgoto error;\n\t}\n\n\t// Read <name>.bNN\n\tvfile_buffer = zero_segment ? \n\t\tr_buf_new_empty(segment->p_memsz) : \n\t\tr_buf_new_file(segment_file_path, O_RDONLY, 0);\n\t\t\n\tif (!vfile_buffer) {\n\t\tR_LOG_ERROR(\"Failed to read '%s'\\n\", segment_file_path);\n\t\tgoto error;\n\t}\n\n\tvfile = r_bin_virtual_file_new(part->name, vfile_buffer, true);\n\tif (!vfile) {\n\t\tgoto error;\n\t}\n\n\tmap = R_NEW0(RBinMap);\n\tif (!map) {\n\t\tgoto error;\n\t}\n\tmap->addr = segment->p_vaddr;\n\tmap->offset = 0;\n\tmap->size = segment->p_filesz;\n\tmap->perms = segment->p_flags & (PF_X | PF_W | PF_R);\n\tmap->file = strdup(part->name);\n\n\tpart->paddr = segment->p_paddr;\n\tpart->pflags = segment->p_flags;\n\tpart->map = map;\n\tpart->vfile = vfile;\n\n\t// Create a section for this segment\n\tRBinSection *bseg = elf_to_bin_segment(segment, part->name);\n\tif (bseg) {\n\t\tr_list_append(part->sections, bseg);\n\t}\n\n\t// Determine format and load object data\n\tif (is_elf32(vfile->buf)) {\n\t\tpart->format = R_BIN_MDT_PART_ELF;\n\t\tif (!load_elf_obj_data(part, segment, vfile, map, big_endian)) {\n\t\t\tgoto error;\n\t\t}\n\t} else if ((segment->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_SIGNATURE) {\n\t\tpart->format = R_BIN_MDT_PART_MBN;\n\t\tif (!load_mbn_obj_data(part, segment, vfile, map)) {\n\t\t\tR_LOG_WARN(\"Failed to load MBN signature segment. Header info won't be available.\\n\");\n\t\t}\n\t} else {\n\t\tpart->format = R_BIN_MDT_PART_UNIDENTIFIED;\n\t\tif (!load_unidentified_obj_data(part, segment, vfile, map)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfree(segment_file_path);\n\treturn part;\n\nerror:\n\tr_bin_mdt_part_free(part);\n\tfree(segment_file_path);\n\treturn NULL;\n}\n\nbool r_bin_mdt_check_filename(const char *filename) {\n\tR_RETURN_VAL_IF_FAIL(filename, false);\n\tif (!filename || strlen(filename) < strlen(\".mdt\")) {\n\t\treturn false;\n\t}\n\tsize_t len = strlen(filename);\n\treturn filename[len - 4] == '.' && \n\t       filename[len - 3] == 'm' && \n\t       filename[len - 2] == 'd' && \n\t       filename[len - 1] == 't';\n}\n\nstatic char *get_peripheral_name(const char *filename) {\n\tif (!r_bin_mdt_check_filename(filename)) {\n\t\treturn NULL;\n\t}\n\tchar *peripheral = strdup(filename);\n\tif (!peripheral) {\n\t\treturn NULL;\n\t}\n\tchar *dot = strrchr(peripheral, '.');\n\tif (!dot) {\n\t\tfree(peripheral);\n\t\treturn NULL;\n\t}\n\t*dot = '\\0';\n\treturn peripheral;\n}\n\nbool r_bin_mdt_load_buffer(RBinFile *bf, RBinObject *obj, RBuffer *buf, Sdb *sdb) {\n\tR_RETURN_VAL_IF_FAIL(obj && buf, false);\n\tif (!r_bin_mdt_check_buffer(buf)) {\n\t\tR_LOG_ERROR(\"Unsupported binary.\\n\");\n\t\treturn false;\n\t}\n\tRBinMdtObj *mdt = r_bin_mdt_obj_new();\n\tif (!mdt) {\n\t\treturn false;\n\t}\n\n\tmdt->name = get_peripheral_name(bf->file);\n\tif (!mdt->name) {\n\t\tR_LOG_ERROR(\"Filename \\\"%s\\\" doesn't indicate it is an .mdt peripheral image.\\n\", bf->file);\n\t\tgoto error;\n\t}\n\n\tmdt->header = Elf_(new_buf)(buf, 0, false);\n\tif (!mdt->header) {\n\t\tR_LOG_ERROR(\"Failed to parse .mdt ELF header.\\n\");\n\t\tgoto error;\n\t}\n\n\t// Process each segment and create parts\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)mdt->header;\n\tfor (size_t i = 0; i < ehdr->e_phnum; i++) {\n\t\tElf32_Phdr phdr;\n\t\tif (r_buf_read_at(buf, ehdr->e_phoff + i * sizeof(phdr), (ut8*)&phdr, sizeof(phdr)) != sizeof(phdr)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tRBinMdtPart *part = segment_to_mdt_part(&phdr, i, mdt->name, Elf_(is_big_endian)(mdt->header));\n\t\tif (part) {\n\t\t\tr_list_append(mdt->parts, part);\n\t\t}\n\t}\n\n\tobj->bin_obj = mdt;\n\treturn true;\n\nerror:\n\tr_bin_mdt_obj_free(mdt);\n\treturn false;\n}\n\nvoid r_bin_mdt_destroy(RBinFile *bf) {\n\tR_RETURN_IF_FAIL(bf && bf->bo && bf->bo->bin_obj);\n\tr_bin_mdt_obj_free(bf->bo->bin_obj);\n}\n\nRList *r_bin_mdt_virtual_files(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *vfiles = r_list_newf((RListFree)r_bin_virtual_file_free);\n\tif (!vfiles) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tRBinVirtualFile *clone = r_bin_virtual_file_clone(part->vfile);\n\t\tif (clone) {\n\t\t\tr_list_append(vfiles, clone);\n\t\t}\n\t\t\n\t\t// Add patches and relocs virtual files if available\n\t\tif (part->patches_vfile_name && part->obj.elf) {\n\t\t\t// TODO: Add patched buffer support\n\t\t}\n\t\tif (part->relocs_vfile_name && part->relocs) {\n\t\t\t// TODO: Add relocs buffer support\n\t\t}\n\t}\n\treturn vfiles;\n}\n\nRList *r_bin_mdt_get_maps(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *maps = r_list_newf(free);\n\tif (!maps) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (!part->sub_maps || part->is_layout) {\n\t\t\t// The first ELF file is always the overall firmware layout\n\t\t\tRBinMap *clone = R_NEW0(RBinMap);\n\t\t\tif (clone && part->map) {\n\t\t\t\tmemcpy(clone, part->map, sizeof(RBinMap));\n\t\t\t\tclone->file = part->map->file ? strdup(part->map->file) : NULL;\n\t\t\t\tr_list_append(maps, clone);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Add the sub maps for ELF parts\n\t\tRListIter *sub_iter;\n\t\tRBinMap *sub_map;\n\t\tr_list_foreach(part->sub_maps, sub_iter, sub_map) {\n\t\t\tRBinMap *clone = R_NEW0(RBinMap);\n\t\t\tif (clone) {\n\t\t\t\tmemcpy(clone, sub_map, sizeof(RBinMap));\n\t\t\t\tclone->file = sub_map->file ? strdup(sub_map->file) : NULL;\n\t\t\t\tr_list_append(maps, clone);\n\t\t\t}\n\t\t}\n\t}\n\treturn maps;\n}\n\nRList *r_bin_mdt_get_entry_points(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *entries = r_list_newf(free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\t\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)mdt->header;\n\tif (!ehdr) {\n\t\tr_list_free(entries);\n\t\treturn NULL;\n\t}\n\n\tRBinAddr *entry = R_NEW0(RBinAddr);\n\tif (!entry) {\n\t\tr_list_free(entries);\n\t\treturn NULL;\n\t}\n\t\n\t// Get entry point from ELF header\n\tentry->paddr = ehdr->e_entry;\n\tentry->vaddr = ehdr->e_entry;\n\tentry->type = R_BIN_ENTRY_TYPE_INIT;\n\tentry->bits = 32;\n\t\n\tr_list_append(entries, entry);\n\treturn entries;\n}\n\nRList *r_bin_mdt_symbols(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *symbols = r_list_newf((RListFree)r_bin_symbol_free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (part->symbols) {\n\t\t\tRListIter *sym_iter;\n\t\t\tRBinSymbol *sym;\n\t\t\tr_list_foreach(part->symbols, sym_iter, sym) {\n\t\t\t\tRBinSymbol *clone = r_bin_symbol_clone(sym);\n\t\t\t\tif (clone) {\n\t\t\t\t\tr_list_append(symbols, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn symbols;\n}\n\nRList *r_bin_mdt_sections(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *sections = r_list_newf((RListFree)r_bin_section_free);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (part->sections) {\n\t\t\tRListIter *sec_iter;\n\t\t\tRBinSection *sec;\n\t\t\tr_list_foreach(part->sections, sec_iter, sec) {\n\t\t\t\tRBinSection *clone = r_bin_section_clone(sec);\n\t\t\t\tif (clone) {\n\t\t\t\t\tr_list_append(sections, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sections;\n}\n\nRList *r_bin_mdt_relocs(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *relocs = r_list_newf((RListFree)r_bin_reloc_free);\n\tif (!relocs) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (part->relocs) {\n\t\t\tRListIter *rel_iter;\n\t\t\tRBinReloc *rel;\n\t\t\tr_list_foreach(part->relocs, rel_iter, rel) {\n\t\t\t\t// Note: RBinReloc doesn't have a clone function in radare2\n\t\t\t\t// so we would need to manually copy or implement cloning\n\t\t\t\tr_list_append(relocs, rel);\n\t\t\t}\n\t\t}\n\t}\n\treturn relocs;\n}\n\n// Header printing function with MBN support from existing plugin\nstatic void mbn_header_obj(SblHeader *sb, PrintfCallback cb) {\n\tif (!sb || !cb) {\n\t\treturn;\n\t}\n\tcb(\"0x00 image_id:   %s (0x%x)\\n\", \"kMbnImageNone\", sb->load_index);\n\tcb(\"0x04 version:    0x%x\\n\", sb->version);\n\tcb(\"0x08 paddr:      0x%x\\n\", sb->paddr);\n\tcb(\"0x0c vaddr:      0x%x\\n\", sb->vaddr);\n\tcb(\"0x10 psize:      0x%x\\n\", sb->psize);\n\tcb(\"0x14 code_pa:    0x%x\\n\", sb->code_pa);\n\tcb(\"0x18 sign_va:    0x%x\\n\", sb->sign_va);\n\tcb(\"0x1c sign_sz:    0x%x\\n\", sb->sign_sz);\n\tcb(\"0x20 cert_va:    0x%x\\n\", sb->cert_va);\n\tcb(\"0x24 cert_sz:    0x%x\\n\", sb->cert_sz);\n}\n\nvoid r_bin_mdt_print_header(RBinFile *bf) {\n\tR_RETURN_IF_FAIL(bf && bf->bo && bf->bo->bin_obj && bf->rbin && bf->rbin->cb_printf);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tchar bits[65] = { 0 };\n\tsize_t i = 0;\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tr_str_bits64(bits, qcom_p_flags(part->pflags));\n\t\tbf->rbin->cb_printf(\"==== MDT Segment %zu ====\\n\", i);\n\t\tbf->rbin->cb_printf(\" priv_p_flags: 0b%s:\", bits);\n\t\tif (part->is_layout) {\n\t\t\tbf->rbin->cb_printf(\" layout\");\n\t\t}\n\t\tif (part->relocatable) {\n\t\t\tbf->rbin->cb_printf(\" reloc\");\n\t\t}\n\t\tswitch (part->format) {\n\t\tdefault:\n\t\tcase R_BIN_MDT_PART_UNIDENTIFIED:\n\t\t\tbf->rbin->cb_printf(\" | Unidentified\\n\");\n\t\t\tbreak;\n\t\tcase R_BIN_MDT_PART_ELF:\n\t\t\tbf->rbin->cb_printf(\" | ELF\\n\");\n\t\t\tif (part->obj.elf) {\n\t\t\t\tbf->rbin->cb_printf(\" -- ELF HEADER BEGIN -- \\n\");\n\t\t\t\t// TODO: Add ELF header printing\n\t\t\t\tbf->rbin->cb_printf(\" --- ELF HEADER END --- \\n\\n\");\n\t\t\t} else {\n\t\t\t\tbf->rbin->cb_printf(\" ------- FAILED ------- \\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_MDT_PART_MBN:\n\t\t\tbf->rbin->cb_printf(\" | MBN signature segment\\n\");\n\t\t\tif (part->obj.mbn) {\n\t\t\t\tbf->rbin->cb_printf(\" -- MBN AUTH HEADER BEGIN -- \\n\");\n\t\t\t\tmbn_header_obj(part->obj.mbn, bf->rbin->cb_printf);\n\t\t\t\tbf->rbin->cb_printf(\" --- MBN AUTH HEADER END --- \\n\\n\");\n\t\t\t} else {\n\t\t\t\tbf->rbin->cb_printf(\" ------- FAILED ------- \\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_BIN_MDT_PART_COMPRESSED_Q6ZIP:\n\t\t\tbf->rbin->cb_printf(\" | Q6ZIP compressed\\n\");\n\t\t\tbreak;\n\t\tcase R_BIN_MDT_PART_COMPRESSED_CLADE2:\n\t\t\tbf->rbin->cb_printf(\" | CLADE2 compressed\\n\");\n\t\t\tbreak;\n\t\tcase R_BIN_MDT_PART_COMPRESSED_ZLIB:\n\t\t\tbf->rbin->cb_printf(\" | ZLIB compressed\\n\");\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n}"