// SPDX-FileCopyrightText: 2025 Rot127 <unisono@quyllur.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"mdt.h\"\n#include \"../elf/elf.h\"\n#include <r_bin.h>\n#include <r_util.h>\n#include <r_io.h>\n#include <r_util/r_assert.h>\n#include <r_util/r_buf.h>\n#include <r_util/r_file.h>\n#include <r_util/r_itv.h>\n#include <r_util/r_str.h>\n#include <r_list.h>\n\n// Virtual file helper functions implementation\nR_IPI RBinVirtualFile *r_bin_virtual_file_new(const char *name, RBuffer *buf, bool buf_owned) {\n\tRBinVirtualFile *vfile = R_NEW0(RBinVirtualFile);\n\tif (!vfile) {\n\t\treturn NULL;\n\t}\n\tvfile->name = name ? strdup(name) : NULL;\n\tvfile->buf = buf;\n\tvfile->buf_owned = buf_owned;\n\treturn vfile;\n}\n\nR_IPI void r_bin_virtual_file_free(RBinVirtualFile *vfile) {\n\tif (!vfile) {\n\t\treturn;\n\t}\n\tif (vfile->buf_owned) {\n\t\tr_buf_free(vfile->buf);\n\t}\n\tfree(vfile->name);\n\tfree(vfile);\n}\n\nR_IPI RBinVirtualFile *r_bin_virtual_file_clone(RBinVirtualFile *vfile) {\n\tif (!vfile) {\n\t\treturn NULL;\n\t}\n\tRBinVirtualFile *clone = R_NEW0(RBinVirtualFile);\n\tif (!clone) {\n\t\treturn NULL;\n\t}\n\tclone->name = vfile->name ? strdup(vfile->name) : NULL;\n\tclone->buf = vfile->buf;\n\tclone->buf_owned = false;  // Don't own the buffer in clones\n\treturn clone;\n}\n\n// MBN APIs - from bin_mbn.c\ntypedef struct sbl_header {\n\tut32 load_index;\n\tut32 version;    // (flash_partition_version) 3 = nand\n\tut32 paddr;      // This + 40 is the start of the code in the file\n\tut32 vaddr;	 // Where it's loaded in memory\n\tut32 psize;      // code_size + signature_size + cert_chain_size\n\tut32 code_pa;    // Only what's loaded to memory\n\tut32 sign_va;\n\tut32 sign_sz;\n\tut32 cert_va;    // Max of 3 certs?\n\tut32 cert_sz;\n} SblHeader;\n\n// MBN functions based on bin_mbn.c\nR_IPI bool mbn_read_sbl_header(RBuffer *buf, SblHeader *h, ut64 *offset) {\n\tif (!buf || !h || !offset) {\n\t\treturn false;\n\t}\n\tut64 bufsz = r_buf_size(buf);\n\tif (sizeof(SblHeader) > bufsz) {\n\t\treturn false;\n\t}\n\tint ret = r_buf_fread_at(buf, *offset, (ut8*)h, \"10i\", 1);\n\tif (!ret) {\n\t\treturn false;\n\t}\n\t// Basic validation like in bin_mbn.c\n\tif (h->version != 3) { // NAND\n\t\treturn false;\n\t}\n\tif (h->paddr + sizeof(SblHeader) > bufsz) {\n\t\treturn false;\n\t}\n\tif (h->vaddr < 0x100 || h->psize > bufsz) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nR_IPI void mbn_destroy_obj(SblHeader *h) {\n\tfree(h);\n}\n\nR_IPI void mbn_header_obj(SblHeader *h, PrintfCallback cb_printf) {\n\tif (!h || !cb_printf) {\n\t\tcb_printf(\"Invalid MBN header\\n\");\n\t\treturn;\n\t}\n\tcb_printf(\"MBN Header:\\n\");\n\tcb_printf(\"  Version: %d\\n\", h->version);\n\tcb_printf(\"  Load Index: %d\\n\", h->load_index);\n\tcb_printf(\"  Physical Address: 0x%08x\\n\", h->paddr);\n\tcb_printf(\"  Virtual Address: 0x%08x\\n\", h->vaddr);\n\tcb_printf(\"  Size: 0x%08x\\n\", h->psize);\n\tcb_printf(\"  Code PA: 0x%08x\\n\", h->code_pa);\n\tcb_printf(\"  Signature VA: 0x%08x Size: 0x%08x\\n\", h->sign_va, h->sign_sz);\n\tcb_printf(\"  Certificate VA: 0x%08x Size: 0x%08x\\n\", h->cert_va, h->cert_sz);\n}\n\n// ELF helper functions implementation\nR_IPI ut64 elf_reloc_targets_vfile_size(struct r_bin_elf_obj_t *elf) {\n\tif (!elf) {\n\t\treturn 0;\n\t}\n\t// Load relocs and calculate total size needed for relocation targets\n\tconst RVector *relocs = Elf_(load_relocs)(elf);\n\tif (!relocs) {\n\t\treturn 0;\n\t}\n\t// Estimate size as number of relocs * pointer size\n\treturn r_vector_len(relocs) * (elf->bits / 8);\n}\n\nR_IPI ut32 qcom_p_flags(ut32 pflags) {\n\t// Process Qualcomm-specific program header flags\n\t// Keep standard ELF flags and add QCOM specific interpretation\n\tut32 result = pflags & (R_PERM_R | R_PERM_W | R_PERM_X);\n\n\t// Check for QCOM specific flags\n\tif (pflags & QCOM_MDT_RELOCATABLE) {\n\t\tresult |= QCOM_MDT_RELOCATABLE;\n\t}\n\n\t// Extract and preserve QCOM type mask\n\tresult |= (pflags & QCOM_MDT_TYPE_MASK);\n\n\treturn result;\n}\n\n// Implementation of patched_maps_elf_only - creates maps for ELF with patches\nR_IPI R_OWN RList *patched_maps_elf_only(struct r_bin_elf_obj_t *elf, ut64 psize, RBuffer *buf, ut64 vaddr, const char *pname, const char *rname) {\n\tif (!elf) {\n\t\treturn r_list_new((RListFree)r_bin_map_free);\n\t}\n\n\tRList *maps = r_list_new((RListFree)r_bin_map_free);\n\tif (!maps) {\n\t\treturn NULL;\n\t}\n\n\t// Create a map for the patched ELF content\n\tRBinMap *map = R_NEW0(RBinMap);\n\tif (!map) {\n\t\tr_list_free(maps);\n\t\treturn NULL;\n\t}\n\n\tmap->name = strdup(pname ? pname : \"patched\");\n\tmap->vaddr = vaddr;\n\tmap->paddr = 0;\n\tmap->psize = psize;\n\tmap->vsize = psize;\n\tmap->perm = R_PERM_R | R_PERM_X;\n\tmap->vfile_name = strdup(pname ? pname : \"patched\");\n\n\tr_list_append(maps, map);\n\n\t// If we have relocations, create a relocs map\n\tif (rname && elf_reloc_targets_vfile_size(elf) > 0) {\n\t\tRBinMap *rmap = R_NEW0(RBinMap);\n\t\tif (rmap) {\n\t\t\trmap->name = strdup(rname);\n\t\t\trmap->vaddr = vaddr + psize;\n\t\t\trmap->paddr = 0;\n\t\t\trmap->psize = elf_reloc_targets_vfile_size(elf);\n\t\t\trmap->vsize = rmap->psize;\n\t\t\trmap->perm = R_PERM_R;\n\t\t\trmap->vfile_name = strdup(rname);\n\t\t\tr_list_append(maps, rmap);\n\t\t}\n\t}\n\n\treturn maps;\n}\n\n// ELF wrapper functions using radare2 APIs\nR_IPI R_OWN RList *elf_symbols_obj(struct r_bin_elf_obj_t *elf) {\n\tif (!elf) {\n\t\treturn r_list_new((RListFree)r_bin_symbol_free);\n\t}\n\n\t// Load symbols using radare2 ELF API\n\tif (!Elf_(load_symbols)(elf)) {\n\t\treturn r_list_new((RListFree)r_bin_symbol_free);\n\t}\n\n\tRList *symbols = r_list_new((RListFree)r_bin_symbol_free);\n\tif (!symbols || !elf->g_symbols_vec) {\n\t\treturn symbols;\n\t}\n\n\t// Convert ELF symbols to RBinSymbol\n\tRBinElfSymbol *symbol;\n\tR_VEC_FOREACH(elf->g_symbols_vec, symbol) {\n\t\tif (symbol->is_sht_null) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *ptr = Elf_(convert_symbol)(elf, symbol);\n\t\tif (ptr) {\n\t\t\tr_list_append(symbols, ptr);\n\t\t}\n\t}\n\n\treturn symbols;\n}\n\nR_IPI R_OWN RList *elf_sections_obj(struct r_bin_elf_obj_t *elf, ut64 psize) {\n\tif (!elf) {\n\t\treturn r_list_new((RListFree)r_bin_section_free);\n\t}\n\n\t// Create a dummy RBinFile for the load_sections call\n\tRBinFile dummy_bf = {0};\n\tdummy_bf.bo = R_NEW0(RBinObject);\n\tif (!dummy_bf.bo) {\n\t\treturn r_list_new((RListFree)r_bin_section_free);\n\t}\n\tdummy_bf.bo->bin_obj = elf;\n\n\t// Load sections using radare2 ELF API\n\tconst RVector *sections = Elf_(load_sections)(&dummy_bf, elf);\n\n\tRList *result = r_list_new((RListFree)r_bin_section_free);\n\tif (sections && result) {\n\t\tRBinSection *section;\n\t\tr_vector_foreach(sections, section) {\n\t\t\tr_list_append(result, r_bin_section_clone(section));\n\t\t}\n\t}\n\n\tfree(dummy_bf.bo);\n\treturn result ? result : r_list_new((RListFree)r_bin_section_free);\n}\n\nR_IPI R_OWN RList *elf_relocs_obj(struct r_bin_elf_obj_t *elf, ut64 vaddr, RBuffer *patched_buf) {\n\tif (!elf) {\n\t\treturn r_list_new((RListFree)r_bin_reloc_free);\n\t}\n\n\t// Load relocs using radare2 ELF API\n\tconst RVector *relocs = Elf_(load_relocs)(elf);\n\tif (!relocs) {\n\t\treturn r_list_new((RListFree)r_bin_reloc_free);\n\t}\n\n\tRList *result = r_list_new((RListFree)r_bin_reloc_free);\n\tif (!result) {\n\t\treturn NULL;\n\t}\n\n\t// Convert ELF relocs to RBinReloc - this is a simplified conversion\n\tRBinElfReloc *reloc;\n\tr_vector_foreach(relocs, reloc) {\n\t\tRBinReloc *ptr = R_NEW0(RBinReloc);\n\t\tif (!ptr) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tptr->vaddr = reloc->rva;\n\t\tptr->paddr = reloc->offset;\n\t\tptr->type = reloc->type;\n\t\tptr->addend = reloc->addend;\n\n\t\tr_list_append(result, ptr);\n\t}\n\n\treturn result;\n}\n\nstatic inline bool is_layout_bin(size_t p_flags) {\n\treturn (p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_LAYOUT;\n}\n\nR_IPI RBinMdtPart *r_bin_mdt_part_new(const char *name, size_t p_flags) {\n\tRBinMdtPart *part = R_NEW0(RBinMdtPart);\n\tif (!part) {\n\t\treturn NULL;\n\t}\n\tpart->name = strdup(name);\n\tpart->relocatable = p_flags & QCOM_MDT_RELOCATABLE;\n\tpart->is_layout = is_layout_bin(p_flags);\n\tpart->symbols = r_list_newf((RListFree)r_bin_symbol_free);\n\tpart->relocs = r_list_newf(free);\n\tpart->sections = r_list_newf((RListFree)r_bin_section_free);\n\tpart->sub_maps = r_list_newf(free);\n\treturn part;\n}\n\nR_IPI void r_bin_mdt_part_free(R_OWN R_NULLABLE RBinMdtPart *part) {\n\tif (!part) {\n\t\treturn;\n\t}\n\tr_bin_virtual_file_free(part->vfile);\n\tswitch (part->format) {\n\tdefault:\n\t\tbreak;\n\tcase R_BIN_MDT_PART_ELF:\n\t\tElf32_r_bin_elf_free(part->obj.elf);\n\t\tbreak;\n\tcase R_BIN_MDT_PART_MBN:\n\t\tmbn_destroy_obj(part->obj.mbn);\n\t\tbreak;\n\t}\n\tr_bin_map_free(part->map);\n\tr_list_free(part->relocs);\n\tr_list_free(part->symbols);\n\tr_list_free(part->sections);\n\tr_list_free(part->sub_maps);\n\tfree(part->patches_vfile_name);\n\tfree(part->relocs_vfile_name);\n\tfree(part->name);\n\tfree(part);\n}\n\nR_IPI RBinMdtObj *r_bin_mdt_obj_new(void) {\n\tRBinMdtObj *obj = R_NEW0(RBinMdtObj);\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tobj->parts = r_list_newf((RListFree)r_bin_mdt_part_free);\n\treturn obj;\n}\n\nR_IPI void r_bin_mdt_obj_free(RBinMdtObj *obj) {\n\tif (!obj) {\n\t\treturn;\n\t}\n\tElf32_r_bin_elf_free(obj->header);\n\tr_list_free(obj->parts);\n\tfree(obj->name);\n\tfree(obj);\n}\n\nstatic inline bool is_elf32(RBuffer *b) {\n\treturn r_bin_elf_check_buffer(NULL, b);\n}\n\nR_IPI bool r_bin_mdt_check_buffer(RBuffer *b) {\n\tr_return_val_if_fail(b, false);\n\tif (!is_elf32(b) || r_buf_size(b) <= R_BIN_ELF_TINY_SIZE) {\n\t\treturn false;\n\t}\n\n\tstruct r_bin_elf_obj_t *elf = NULL;\n\tRBinObjectOptions obj_opts = {\n\t\t.baddr = 0,\n\t\t.laddr = 0,\n\t\t.elf_load_sections = false,\n\t};\n\telf = r_bin_elf_new_buf(b, &obj_opts);\n\tif (!elf || !elf->segments) {\n\t\tr_bin_elf_free(elf);\n\t\treturn false;\n\t}\n\tRBinElfSegment *sgmt = r_vector_head(elf->segments);\n\tif (!sgmt) {\n\t\tr_bin_elf_free(elf);\n\t\treturn false;\n\t}\n\tbool mdt_flags_set = is_layout_bin(sgmt->data.p_flags);\n\tr_bin_elf_free(elf);\n\treturn mdt_flags_set;\n}\n\nstatic bool load_unidentified_obj_data(RBinMdtPart *part, void *segment, RBinVirtualFile *vfile, RBinMap *map) {\n\tR_RETURN_VAL_IF_FAIL(part && segment && vfile && map, false);\n\treturn true;\n}\n\nstatic bool load_mbn_obj_data(RBinMdtPart *part, void *segment, RBinVirtualFile *vfile, RBinMap *map) {\n\tR_RETURN_VAL_IF_FAIL(part && segment && vfile && map, false);\n\n\tSblHeader *mbn = R_NEW0(SblHeader);\n\tut64 offset = 0;\n\tif (!mbn) {\n\t\treturn false;\n\t}\n\t\n\t// Read MBN header - structure from bin_mbn.c\n\tif (r_buf_read_at(vfile->buf, offset, (ut8*)mbn, sizeof(SblHeader)) != sizeof(SblHeader)) {\n\t\tfree(mbn);\n\t\treturn false;\n\t}\n\t\n\t// Basic validation\n\tif (mbn->version != 3) { // NAND\n\t\tfree(mbn);\n\t\treturn false;\n\t}\n\t\n\tpart->obj.mbn = mbn;\n\treturn true;\n}\n\nstatic void prefix_name(char **to_prefix, const char *prefix) {\n\tR_RETURN_IF_FAIL(to_prefix && prefix);\n\tconst char *separator = (*to_prefix)[0] == '.' ? \"\" : \".\";\n\tchar *prefixed_name = r_str_newf(\"%s%s%s\", prefix, separator, \n\t\t\t\t\t R_STR_ISEMPTY(*to_prefix) ? \"0x0\" : *to_prefix);\n\tfree(*to_prefix);\n\t*to_prefix = prefixed_name;\n}\n\nstatic bool load_elf_obj_data(RBinMdtPart *part, void *segment, RBinVirtualFile *vfile, RBinMap *map, bool big_endian) {\n\tR_RETURN_VAL_IF_FAIL(part && segment && vfile && map, false);\n\n\tvoid *elf = Elf_(new_buf)(vfile->buf, 0, false);\n\tif (!elf) {\n\t\tR_LOG_ERROR(\"Failed to load segment '%s' as ELF.\\n\", part->name);\n\t\treturn false;\n\t}\n\n\tpart->obj.elf = elf;\n\tpart->patches_vfile_name = r_str_newf(\"patches.%s\", part->name);\n\tpart->relocs_vfile_name = r_str_newf(\"relocs.%s\", part->name);\n\n\t// TODO: Add symbol/section/reloc extraction here\n\t// This requires more complex ELF parsing that would need significant\n\t// additional work to port from Rizin's advanced ELF handling\n\t\n\treturn true;\n}\n\nstatic RBinSection *elf_to_bin_segment(void *segment_ptr, const char *name) {\n\tRBinSection *bseg = R_NEW0(RBinSection);\n\tif (!bseg) {\n\t\treturn NULL;\n\t}\n\n\t// Cast to Elf32_Phdr\n\tElf32_Phdr *segment = (Elf32_Phdr *)segment_ptr;\n\t\n\tbseg->paddr = segment->p_paddr;\n\tbseg->size = segment->p_filesz;\n\tbseg->vsize = segment->p_memsz;\n\tbseg->vaddr = segment->p_vaddr;\n\tbseg->perm = segment->p_flags & (PF_X | PF_W | PF_R);\n\tbseg->is_segment = true;\n\tbseg->is_data = !(segment->p_flags & PF_X);\n\tbseg->flags = segment->p_flags;\n\tbseg->name = name ? strdup(name) : NULL;\n\treturn bseg;\n}\n\nstatic RBinMdtPart *segment_to_mdt_part(void *segment_ptr, size_t part_num, const char *suffix_less_path, bool big_endian) {\n\tElf32_Phdr *segment = (Elf32_Phdr *)segment_ptr;\n\tRBuffer *vfile_buffer = NULL;\n\tchar *segment_file_path = NULL;\n\tRBinMdtPart *part = NULL;\n\tRBinMap *map = NULL;\n\tRBinVirtualFile *vfile = NULL;\n\n\tsegment_file_path = r_str_newf(\"%s.b%02zu\", suffix_less_path, part_num);\n\tif (!segment_file_path) {\n\t\tgoto error;\n\t}\n\tconst char *segment_name = r_file_basename(segment_file_path);\n\tif (!segment_name) {\n\t\tsegment_name = segment_file_path;\n\t}\n\tpart = r_bin_mdt_part_new(segment_name, segment->p_flags);\n\tif (!part) {\n\t\tgoto error;\n\t}\n\n\tbool segment_file_exists = r_file_exists(segment_file_path);\n\tbool zero_segment = segment->p_filesz == 0;\n\tif (zero_segment && segment_file_exists) {\n\t\tR_LOG_WARN(\"The segment size for '%s' is 0. But the file exists. Skip loading.\\n\", segment_file_path);\n\t\tgoto error;\n\t} else if (!zero_segment && !segment_file_exists) {\n\t\tR_LOG_WARN(\"The segment size for '%s' is 0x%x. But the file doesn't exist. Skip loading.\\n\", \n\t\t\t   segment_file_path, segment->p_filesz);\n\t\tgoto error;\n\t}\n\n\t// Read <name>.bNN\n\tvfile_buffer = zero_segment ? \n\t\tr_buf_new_empty(segment->p_memsz) : \n\t\tr_buf_new_file(segment_file_path, O_RDONLY, 0);\n\t\t\n\tif (!vfile_buffer) {\n\t\tR_LOG_ERROR(\"Failed to read '%s'\\n\", segment_file_path);\n\t\tgoto error;\n\t}\n\n\tvfile = r_bin_virtual_file_new(part->name, vfile_buffer, true);\n\tif (!vfile) {\n\t\tgoto error;\n\t}\n\n\tmap = R_NEW0(RBinMap);\n\tif (!map) {\n\t\tgoto error;\n\t}\n\tmap->addr = segment->p_vaddr;\n\tmap->offset = 0;\n\tmap->size = segment->p_filesz;\n\tmap->perms = segment->p_flags & (PF_X | PF_W | PF_R);\n\tmap->file = strdup(part->name);\n\n\tpart->paddr = segment->p_paddr;\n\tpart->pflags = segment->p_flags;\n\tpart->map = map;\n\tpart->vfile = vfile;\n\n\t// Create a section for this segment\n\tRBinSection *bseg = elf_to_bin_segment(segment, part->name);\n\tif (bseg) {\n\t\tr_list_append(part->sections, bseg);\n\t}\n\n\t// Determine format and load object data\n\tif (is_elf32(vfile->buf)) {\n\t\tpart->format = R_BIN_MDT_PART_ELF;\n\t\tif (!load_elf_obj_data(part, segment, vfile, map, big_endian)) {\n\t\t\tgoto error;\n\t\t}\n\t} else if ((segment->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_SIGNATURE) {\n\t\tpart->format = R_BIN_MDT_PART_MBN;\n\t\tif (!load_mbn_obj_data(part, segment, vfile, map)) {\n\t\t\tR_LOG_WARN(\"Failed to load MBN signature segment. Header info won't be available.\\n\");\n\t\t}\n\t} else {\n\t\tpart->format = R_BIN_MDT_PART_UNIDENTIFIED;\n\t\tif (!load_unidentified_obj_data(part, segment, vfile, map)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfree(segment_file_path);\n\treturn part;\n\nerror:\n\tr_bin_mdt_part_free(part);\n\tfree(segment_file_path);\n\treturn NULL;\n}\n\nbool r_bin_mdt_check_filename(const char *filename) {\n\tR_RETURN_VAL_IF_FAIL(filename, false);\n\tif (!filename || strlen(filename) < strlen(\".mdt\")) {\n\t\treturn false;\n\t}\n\tsize_t len = strlen(filename);\n\treturn filename[len - 4] == '.' && \n\t       filename[len - 3] == 'm' && \n\t       filename[len - 2] == 'd' && \n\t       filename[len - 1] == 't';\n}\n\nstatic char *get_peripheral_name(const char *filename) {\n\tif (!r_bin_mdt_check_filename(filename)) {\n\t\treturn NULL;\n\t}\n\tchar *peripheral = strdup(filename);\n\tif (!peripheral) {\n\t\treturn NULL;\n\t}\n\tchar *dot = strrchr(peripheral, '.');\n\tif (!dot) {\n\t\tfree(peripheral);\n\t\treturn NULL;\n\t}\n\t*dot = '\\0';\n\treturn peripheral;\n}\n\nbool r_bin_mdt_load_buffer(RBinFile *bf, RBinObject *obj, RBuffer *buf, Sdb *sdb) {\n\tR_RETURN_VAL_IF_FAIL(obj && buf, false);\n\tif (!r_bin_mdt_check_buffer(buf)) {\n\t\tR_LOG_ERROR(\"Unsupported binary.\\n\");\n\t\treturn false;\n\t}\n\tRBinMdtObj *mdt = r_bin_mdt_obj_new();\n\tif (!mdt) {\n\t\treturn false;\n\t}\n\n\tmdt->name = get_peripheral_name(bf->file);\n\tif (!mdt->name) {\n\t\tR_LOG_ERROR(\"Filename \\\"%s\\\" doesn't indicate it is an .mdt peripheral image.\\n\", bf->file);\n\t\tgoto error;\n\t}\n\n\tmdt->header = Elf_(new_buf)(buf, 0, false);\n\tif (!mdt->header) {\n\t\tR_LOG_ERROR(\"Failed to parse .mdt ELF header.\\n\");\n\t\tgoto error;\n\t}\n\n\t// Process each segment and create parts\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)mdt->header;\n\tfor (size_t i = 0; i < ehdr->e_phnum; i++) {\n\t\tElf32_Phdr phdr;\n\t\tif (r_buf_read_at(buf, ehdr->e_phoff + i * sizeof(phdr), (ut8*)&phdr, sizeof(phdr)) != sizeof(phdr)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tRBinMdtPart *part = segment_to_mdt_part(&phdr, i, mdt->name, Elf_(is_big_endian)(mdt->header));\n\t\tif (part) {\n\t\t\tr_list_append(mdt->parts, part);\n\t\t}\n\t}\n\n\tobj->bin_obj = mdt;\n\treturn true;\n\nerror:\n\tr_bin_mdt_obj_free(mdt);\n\treturn false;\n}\n\nvoid r_bin_mdt_destroy(RBinFile *bf) {\n\tR_RETURN_IF_FAIL(bf && bf->bo && bf->bo->bin_obj);\n\tr_bin_mdt_obj_free(bf->bo->bin_obj);\n}\n\nRList *r_bin_mdt_virtual_files(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *vfiles = r_list_newf((RListFree)r_bin_virtual_file_free);\n\tif (!vfiles) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tRBinVirtualFile *clone = r_bin_virtual_file_clone(part->vfile);\n\t\tif (clone) {\n\t\t\tr_list_append(vfiles, clone);\n\t\t}\n\t\t\n\t\t// Add patches and relocs virtual files if available\n\t\tif (part->patches_vfile_name && part->obj.elf) {\n\t\t\t// TODO: Add patched buffer support\n\t\t}\n\t\tif (part->relocs_vfile_name && part->relocs) {\n\t\t\t// TODO: Add relocs buffer support\n\t\t}\n\t}\n\treturn vfiles;\n}\n\nRList *r_bin_mdt_get_maps(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *maps = r_list_newf(free);\n\tif (!maps) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (!part->sub_maps || part->is_layout) {\n\t\t\t// The first ELF file is always the overall firmware layout\n\t\t\tRBinMap *clone = R_NEW0(RBinMap);\n\t\t\tif (clone && part->map) {\n\t\t\t\tmemcpy(clone, part->map, sizeof(RBinMap));\n\t\t\t\tclone->file = part->map->file ? strdup(part->map->file) : NULL;\n\t\t\t\tr_list_append(maps, clone);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Add the sub maps for ELF parts\n\t\tRListIter *sub_iter;\n\t\tRBinMap *sub_map;\n\t\tr_list_foreach(part->sub_maps, sub_iter, sub_map) {\n\t\t\tRBinMap *clone = R_NEW0(RBinMap);\n\t\t\tif (clone) {\n\t\t\t\tmemcpy(clone, sub_map, sizeof(RBinMap));\n\t\t\t\tclone->file = sub_map->file ? strdup(sub_map->file) : NULL;\n\t\t\t\tr_list_append(maps, clone);\n\t\t\t}\n\t\t}\n\t}\n\treturn maps;\n}\n\nRList *r_bin_mdt_get_entry_points(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *entries = r_list_newf(free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\t\n\tElf32_Ehdr *ehdr = (Elf32_Ehdr *)mdt->header;\n\tif (!ehdr) {\n\t\tr_list_free(entries);\n\t\treturn NULL;\n\t}\n\n\tRBinAddr *entry = R_NEW0(RBinAddr);\n\tif (!entry) {\n\t\tr_list_free(entries);\n\t\treturn NULL;\n\t}\n\t\n\t// Get entry point from ELF header\n\tentry->paddr = ehdr->e_entry;\n\tentry->vaddr = ehdr->e_entry;\n\tentry->type = R_BIN_ENTRY_TYPE_INIT;\n\tentry->bits = 32;\n\t\n\tr_list_append(entries, entry);\n\treturn entries;\n}\n\nRList *r_bin_mdt_symbols(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *symbols = r_list_newf((RListFree)r_bin_symbol_free);\n\tif (!symbols) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (part->symbols) {\n\t\t\tRListIter *sym_iter;\n\t\t\tRBinSymbol *sym;\n\t\t\tr_list_foreach(part->symbols, sym_iter, sym) {\n\t\t\t\tRBinSymbol *clone = r_bin_symbol_clone(sym);\n\t\t\t\tif (clone) {\n\t\t\t\t\tr_list_append(symbols, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn symbols;\n}\n\nRList *r_bin_mdt_sections(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *sections = r_list_newf((RListFree)r_bin_section_free);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (part->sections) {\n\t\t\tRListIter *sec_iter;\n\t\t\tRBinSection *sec;\n\t\t\tr_list_foreach(part->sections, sec_iter, sec) {\n\t\t\t\tRBinSection *clone = r_bin_section_clone(sec);\n\t\t\t\tif (clone) {\n\t\t\t\t\tr_list_append(sections, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sections;\n}\n\nRList *r_bin_mdt_relocs(RBinFile *bf) {\n\tR_RETURN_VAL_IF_FAIL(bf && bf->bo && bf->bo->bin_obj, NULL);\n\tconst RBinMdtObj *mdt = bf->bo->bin_obj;\n\tRList *relocs = r_list_newf((RListFree)r_bin_reloc_free);\n\tif (!relocs) {\n\t\treturn NULL;\n\t}\n\t\n\tRListIter *iter;\n\tRBinMdtPart *part;\n\tr_list_foreach(mdt->parts, iter, part) {\n\t\tif (part->relocs) {\n\t\t\tRListIter *rel_iter;\n\t\t\tRBinReloc *rel;\n\t\t\tr_list_foreach(part->relocs, rel_iter, rel) {\n\t\t\t\t// Note: RBinReloc doesn't have a clone function in radare2\n\t\t\t\t// so we would need to manually copy or implement cloning\n\t\t\t\tr_list_append(relocs, rel);\n\t\t\t}\n\t\t}\n\t}\n\treturn relocs;\n}\n\n// Header printing function with MBN support from existing plugin
static void mbn_header_obj_wrapper(SblHeader *sb, PrintfCallback cb) {
	if (!sb || !cb) {
		return;
	}
	cb("0x00 image_id:   %s (0x%x)\n", "kMbnImageNone", sb->load_index);
	cb("0x04 version:    0x%x\n", sb->version);
	cb("0x08 paddr:      0x%x\n", sb->paddr);
	cb("0x0c vaddr:      0x%x\n", sb->vaddr);
	cb("0x10 psize:      0x%x\n", sb->psize);
	cb("0x14 code_pa:    0x%x\n", sb->code_pa);
	cb("0x18 sign_va:    0x%x\n", sb->sign_va);
	cb("0x1c sign_sz:    0x%x\n", sb->sign_sz);
	cb("0x20 cert_va:    0x%x\n", sb->cert_va);
	cb("0x24 cert_sz:    0x%x\n", sb->cert_sz);
}

R_IPI void r_bin_mdt_print_header(RBinFile *bf) {
	R_RETURN_IF_FAIL(bf && bf->bo && bf->bo->bin_obj && bf->rbin && bf->rbin->cb_printf);
	const RBinMdtObj *mdt = bf->bo->bin_obj;
	char bits[65] = { 0 };
	size_t i = 0;
	
	RListIter *iter;
	RBinMdtPart *part;
	r_list_foreach(mdt->parts, iter, part) {
		r_str_bits64(bits, qcom_p_flags(part->pflags));
		bf->rbin->cb_printf("==== MDT Segment %zu ====\n", i);
		bf->rbin->cb_printf(" priv_p_flags: 0b%s:", bits);
		if (part->is_layout) {
			bf->rbin->cb_printf(" layout");
		}
		if (part->relocatable) {
			bf->rbin->cb_printf(" reloc");
		}
		switch (part->format) {
		default:
		case R_BIN_MDT_PART_UNIDENTIFIED:
			bf->rbin->cb_printf(" | Unidentified\n");
			break;
		case R_BIN_MDT_PART_ELF:
			bf->rbin->cb_printf(" | ELF\n");
			if (part->obj.elf) {
				bf->rbin->cb_printf(" -- ELF HEADER BEGIN -- \n");
				// TODO: Add ELF header printing
				bf->rbin->cb_printf(" --- ELF HEADER END --- \n\n");
			} else {
				bf->rbin->cb_printf(" ------- FAILED ------- \n");
			}
			break;
		case R_BIN_MDT_PART_MBN:
			bf->rbin->cb_printf(" | MBN signature segment\n");
			if (part->obj.mbn) {
				bf->rbin->cb_printf(" -- MBN AUTH HEADER BEGIN -- \n");
				mbn_header_obj_wrapper(part->obj.mbn, bf->rbin->cb_printf);
				bf->rbin->cb_printf(" --- MBN AUTH HEADER END --- \n\n");
			} else {
				bf->rbin->cb_printf(" ------- FAILED ------- \n");
			}
			break;
		case R_BIN_MDT_PART_COMPRESSED_Q6ZIP:
			bf->rbin->cb_printf(" | Q6ZIP compressed\n");
			break;
		case R_BIN_MDT_PART_COMPRESSED_CLADE2:
			bf->rbin->cb_printf(" | CLADE2 compressed\n");
			break;
		case R_BIN_MDT_PART_COMPRESSED_ZLIB:
			bf->rbin->cb_printf(" | ZLIB compressed\n");
			break;
		}
		i++;
	}
}