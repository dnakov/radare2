// SPDX-FileCopyrightText: 2025 Rot127 <unisono@quyllur.org>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n/**\n * \\file Loader for the Qualcomm peripheral firmware images.\n *\n * Reference: https://github.com/torvalds/linux/blob/master/drivers/soc/qcom/mdt_loader.c\n */\n\n#ifndef R_BIN_MDT_H\n#define R_BIN_MDT_H\n\n#include <r_bin.h>\n#include <r_util.h>\n#include <r_types.h>\n\n#define qcom_p_flags(p_flags) ((p_flags) >> 24)\n\n/**\n * \\brief Mask for the segment type.\n */\n#define QCOM_MDT_TYPE_MASK (7 << 24)\n/**\n * \\brief Bits set for the first firmware part.\n */\n#define QCOM_MDT_TYPE_LAYOUT (7 << 24)\n/**\n * \\brief Type of the signature segment.\n */\n#define QCOM_MDT_TYPE_SIGNATURE (2 << 24)\n/**\n * \\brief Relocatable segment.\n */\n#define QCOM_MDT_RELOCATABLE (1 << 27)\n\n/**\n * \\brief The segment type/p_type as it is in the ELF.\n */\ntypedef ut32 RBinMdtPFlags;\n\ntypedef enum r_bin_mdt_seg_type {\n\tR_BIN_MDT_PART_UNIDENTIFIED = 0,\n\tR_BIN_MDT_PART_ELF, ///< An ELF file.\n\tR_BIN_MDT_PART_MBN, ///< The secure boot authentication signature segment.\n\tR_BIN_MDT_PART_COMPRESSED_Q6ZIP, ///< Q6ZIP compressed segment (if identified).\n\tR_BIN_MDT_PART_COMPRESSED_CLADE2, ///< CLADE2 compressed segment (if identified).\n\tR_BIN_MDT_PART_COMPRESSED_ZLIB, ///< Zlib compressed segment (if identified).\n} RBinMdtSegBinFormat;\n\n// Forward declarations\ntypedef struct sbl_header SblHeader;\ntypedef struct r_bin_virtual_file RBinVirtualFile;\n\n/**\n * \\brief Simple virtual file structure for radare2\n */\ntypedef struct r_bin_virtual_file {\n\tchar *name;\n\tRBuffer *buf;\n\tbool buf_owned;\n} RBinVirtualFile;\n\n/**\n * \\brief An MDT firmware part and some descriptions.\n */\ntypedef struct r_bin_mdt_part {\n\tchar *name; ///< The name of the part. Should be equal to the base name of the file.\n\tbool relocatable; ///< True if the Qualcomm relocatable flag is set for the segment.\n\tbool is_layout; ///< True if the ELF segment is the firmware layout.\n\tRBinMdtSegBinFormat format; ///< The segment type.\n\tRBinMdtPFlags pflags; ///< The segment p_flags.\n\tRBinVirtualFile *vfile; ///< The virtual file for the `.bNN` file.\n\tunion {\n\t\tvoid *elf; ///< Set if this part is an ELF.\n\t\tSblHeader *mbn; ///< Set if this part is an MBN auth segment.\n\t} obj;\n\tRBinAddr *entry; ///< The entry point, if any.\n\tRBinMap *map; ///< The mapping of the part in memory.\n\t/**\n\t * \\brief The physical address as in the layout. This is not the same as map->addr!\n\t * Because map is used to read from the files. So it has be zero (to not mess up the reading offsets).\n\t */\n\tut64 paddr;\n\tchar *patches_vfile_name; ///< Name of the vfile of patches to the binary. If NULL, no patches are supported.\n\tchar *relocs_vfile_name; ///< Name of the vfile of relocs to the binary. If NULL, no relocs are supported.\n\tRList *symbols; ///< Symbols in this part.\n\tRList *relocs; ///< Relocs in this part.\n\tRList *sections; ///< Sections in this part.\n\tRList *sub_maps; ///< Maps of the obj, if any.\n} RBinMdtPart;\n\ntypedef struct r_bin_mdt_obj {\n\tchar *name; ///< The name of the peripheral firmware. E.g. modem, adsp, cdsp or npu.\n\tvoid *header; ///< The ELF header of the whole firmware. From `<peripheral>.mdt`.\n\tRList *parts; ///< All parts from the `<peripheral>.bNN` files.\n} RBinMdtObj;\n\n// Function declarations\nRBinMdtPart *r_bin_mdt_part_new(const char *name, size_t p_flags);\nvoid r_bin_mdt_part_free(RBinMdtPart *part);\nRBinMdtObj *r_bin_mdt_obj_new();\nvoid r_bin_mdt_obj_free(RBinMdtObj *obj);\nbool r_bin_mdt_check_filename(const char *filename);\nbool r_bin_mdt_load_buffer(RBinFile *bf, RBinObject *obj, RBuffer *buf, Sdb *sdb);\nbool r_bin_mdt_check_buffer(RBuffer *b);\nvoid r_bin_mdt_destroy(RBinFile *bf);\nRList *r_bin_mdt_get_maps(RBinFile *bf);\nRList *r_bin_mdt_get_entry_points(RBinFile *bf);\nRList *r_bin_mdt_virtual_files(RBinFile *bf);\nRList *r_bin_mdt_symbols(RBinFile *bf);\nvoid r_bin_mdt_print_header(RBinFile *bf);\nRList *r_bin_mdt_sections(RBinFile *bf);\nRList *r_bin_mdt_relocs(RBinFile *bf);\n\n// Helper functions\nRBinVirtualFile *r_bin_virtual_file_new(const char *name, RBuffer *buf, bool buf_owned);\nvoid r_bin_virtual_file_free(RBinVirtualFile *vfile);\nRBinVirtualFile *r_bin_virtual_file_clone(RBinVirtualFile *vfile);\n\n#endif // R_BIN_MDT_H